package c4

import (
	"bufio"
	"bytes"
	"io"
	"os"

	"github.com/blang/vfs"
)

type Event interface {
	ID() *ID
	Stat() (os.FileInfo, error)
	String() string
	Topic() []byte
}

type IdNeededEvent struct {
	path   []byte
	info   *dot
	reader io.Reader
	fs     *vfs.RoFS // IdNeededEvent may only read data.
	f      vfs.File
	data   []byte
	id     *ID
}

// TODO
func (e *IdNeededEvent) String() string {
	return "IdNeededEvent"
}

// Vfs set the virtual file-system source for data.
// IdNeededEvent casts fs to a vfs.ReadOnly file-system.
func (e *IdNeededEvent) Vfs(fs vfs.Filesystem) vfs.Filesystem {
	previous_fs := e.fs
	if fs != nil {
		e.fs = vfs.ReadOnly(fs)
	}
	return previous_fs
}

// ID returns the C4 ID of the content pointed to by the event.
func (e *IdNeededEvent) ID() *ID {
	if e.id != nil {
		return e.id
	}
	r := e.Open()
	if r == nil {
		return nil
	}
	id, err := Identify(r)
	if err != nil {
		return nil
	}
	e.id = id
	e.Close()
	return e.id
}

// IdNeededEvent is an io.ReadCloser
func (e *IdNeededEvent) Open() io.Reader {
	if e.reader != nil {
		return e.reader
	}
	if e.fs == nil {
		e.reader = bytes.NewBuffer(e.data)
		return e.reader
	}
	f, err := e.fs.OpenFile(string(e.path), os.O_RDONLY, 0700)
	if err != nil {
		panic(err)
	}
	e.f = f
	e.reader = bufio.NewReader(f)
	return e.reader
}

func (e *IdNeededEvent) Close() error {
	e.reader = nil
	if e.f == nil {
		return nil
	}
	return e.f.Close()
}

func (e *IdNeededEvent) Stat() (os.FileInfo, error) {
	return e.info, nil
}

func (e *IdNeededEvent) Topic() []byte {
	return e.path
}

