package id

// import "fmt"

// rowAndSize computes the row count, and total number of nodes in the tree.
func rowAndSize(l int) (row_count, tree_size int) {
	row_count = 1
	tree_size = 1
	for ; l > 1; l = (l + 1) / 2 {
		row_count++
		tree_size += l
	}
	return row_count, tree_size
}

// Start and end index of a row within the flat array.
type row_index struct {
	s int
	e int
}

// treeIndexes computes the start and end index of each row in the tree
func treeIndexes(length, rows, nodes int) (ranges []row_index) {
	ranges = make([]row_index, rows)
	offset := (nodes - length)
	remaining := length

	for i := rows - 1; i > 0; i-- {
		ranges[i] = row_index{
			s: offset,
			e: (offset + remaining),
		}
		remaining = (remaining + 1) / 2
		offset = offset - remaining
	}

	ranges[0] = row_index{
		s: 0,
		e: 1,
	}

	return ranges
}

// allocateTree creates the storage array for a tree, and an array of
// byte slices that are used as a row oriented 'view' of the data.
func allocateTree(length int) ([][]byte, []byte) {
	// Compute the number nodes and rows in the tree.
	row_count, node_count := rowAndSize(length)

	// Allocate the storage
	buffer := make([]byte, node_count*64)
	rows := make([][]byte, row_count)

	// Compute the start and end index of each row.
	ranges := treeIndexes(length, row_count, node_count)

	for i, r := range ranges {
		// Here we are not creating a new allocation and copying the
		// data, which is empty at this point anyway. Instead by assigning
		// the the range from the buffer the row array becomes a 'window' into the
		// data array.
		s := r.s * 64
		e := r.e * 64
		rows[i] = buffer[s:e]
	}
	return rows, buffer
}

// listSize computes the length of the list represented by a
// tree given `total` number of nodes in the tree.
func listSize(total int) int {
	// Given that:
	//    total >= 2*len(list)-1
	//  and
	//    total <= 2*len(list)-1+log2(len(list))
	// The range of possible values for length are:
	max := (total + 1) / 2
	min := max - log2(total)

	length := min
	t := treeSize(length)
	if t == total {
		return min
	}
	length = max
	t = treeSize(length)
	if t == total {
		return max
	}

	// For a list of length < 2^64 this will loop less than 6 times before
	// returning.
	for {
		length = (max + min) / 2
		t = treeSize(length)
		if length == min {
			panic("invalid tree size")
		}

		if t > total {
			max = length
		} else if t < total {
			min = length
		} else {
			return length
		}
	}
}

// treeSize computes the total number of nodes required to represent
// a list of length `l` elements.
func treeSize(l int) int {
	// Account for the root node
	total := 1
	for ; l > 1; l = (l + 1) / 2 {
		total = total + l
	}
	return total
}

// Code below is copied from the golang bits package scheduled for inclusion
// in go 1.9. Once that package becomes available the code below this line can
// can be removed and calls to log2 can be replaced with bits.Log2.
func log2(x int) int {
	return bitsLen64(uint64(x)) - 1
}

var len8tab = [256]uint8{
	0x00, 0x01, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
}

func bitsLen64(x uint64) (n int) {
	if x >= 1<<32 {
		x >>= 32
		n = 32
	}
	if x >= 1<<16 {
		x >>= 16
		n += 16
	}
	if x >= 1<<8 {
		x >>= 8
		n += 8
	}
	return n + int(len8tab[x])
}
